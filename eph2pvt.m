function [health,satPos,satVel,satClkCorr,relCorr,tgd] = eph2pvt(ephemeris,t_input,prn)

%==========================================================================
%==========================================================================
% [health,x] = alm2pos(ephem_all,t_input,prn)
%
% Calculates the position from an ephemeris 
%  matrix (see read_GPSbroadcast.m).  The input ephem_all can 
%  be generated by the read_GPSyuma.m or read_GPSbroadcast.m function.
%
% Modified by Y. Wang 9/20/2023 for cleaning up & HW clarification
% Modified by P. Axelrad 9/10/2018 to remove extra functionality
% Author: Ben K. Bradley
% Date: 07/19/2009
%
%
% INPUT:               Description                                  Units
%
%  ephem_all    - matrix of gps satellite orbit parameters           (nx25)
%  
%                  col1: prn, PRN number of satellite
%                  col2: M0, mean anomaly at reference time, rad
%                  col3: delta_n, mean motion difference from computed value, rad/s
%                  col4: ecc, eccentricity of orbit
%                  col5: sqrt_a, square root of semi-major axis, m^0.5
%                  col6: Loa, longitude of ascending node of orbit plane at weekly epoch, rad
%                  col7: incl, inclination angle at reference time, rad
%                  col8: perigee, argument of perigee, rad
%                  col9: ra_rate, rate of change of right ascension, rad/s
%                 col10: i_rate, rate of change of inclination angle, rad/s
%                 col11: Cuc, amplitude of the cosine harmonic correction term to the argument of latitude
%                 col12: Cus, amplitude of the sine harmonic correction term to the argument of latitude
%                 col13: Crc, amplitude of the cosine harmonic correction term to the orbit radius
%                 col14: Crs, amplitude of the sine harmonic correction term to the orbit radius
%                 col15: Cic, amplitude of the cosine harmonic correction term to the angle of inclination
%                 col16: Cis, amplitude of the cosine harmonic correction term to the angle of inclination
%                 col17: Toe, reference time ephemeris (seconds into GPS week)
%                 col18: IODE, issue of data (ephemeris) 
%                 col19: GPS_week, GPS Week Number (to go with Toe) wrt 06jan80 (no rollover)
%                 col20: Toc, time of clock
%                 col21: Af0, satellite clock bias (sec)
%                 col22: Af1, satellite clock drift (sec/sec)
%                 col23: Af2, satellite clock drift rate (sec/sec/sec)
%                 col24: blank (zero)
%                 col25: health, satellite health (0=good and usable)
%
%
%  t_input      - GPS times to calculate values at                 [WN TOW] (nx2)
%  prn          - PRN to compute values for (one satellite only)                       
%
%
% OUTPUT:       
%    
%  health       - health of satellite (0=good)                              (nx1)
%  x            - position of satellite (ECEF)                  [x y z]   m (nx3)
%                                     
%

% Coupling:
%
%   mean2eccentric.m
%
% References:
% 
%   [1] Interface Control Document: IS-GPS-200D
%         < http://www.navcen.uscg.gov/gps/geninfo/IS-GPS-200D.pdf >
%
%   [2] Zhang, J., et.all. "GPS Satellite Velocity and Acceleration
%         Determination using the Broadcast Ephemeris". The Journal of
%         Navigation. (2006), 59, 293-305.
%            < http://journals.cambridge.org/action/displayAbstract;jsess ...
%                ionid=C6B8C16A69DD7C910989C661BAB15E07.tomcat1?fromPage=online&aid=425362 >
%
%   [3] skyplot.cpp by the National Geodetic Survey
%          < http://www.ngs.noaa.gov/gps-toolbox/skyplot/skyplot.cpp >
%
%
%
%  2015/01/22  B.K. Bradley - the capability to look for updated ephem
%                              entries that occur at odd times within each
%                              2hr window has been commented out in this 
%                              function and added to read_GPSbroadcast.m
%                              instead. This moves the computational
%                              overhead to the reading which only occurs
%                              once.
%
%  2021/09/10 P. Axelrad - removed variables not included in the almanac
%  model.
%
%==========================================================================
%==========================================================================

% Load GPS Accepted WGS-84 Constants 
muE = 3.986005e14;     % WGS-84 value, m^3/s^2
wE  = 7.2921151467e-5; % WGS-84 value, rad/s 
c   = 2.99792458e8;    % SI speed of light, m/s

% Initialize Output Variables for Speed 
sz         = size(t_input,1);
satPos     = ones(sz,3) * NaN;
satVel     = ones(sz,3) * NaN;
satClkCorr = ones(sz,1) * NaN;
relCorr    = ones(sz,1) * NaN;
tgd        = ones(sz,1) * NaN; 
health     = ones(sz,1) * NaN; 

% Pull out ephemerides for the selected PRN
kk  = find(ephemeris(:,1) == prn);  
sat_eph0 = ephemeris(kk,:);        

% If no matching PRN found, returning data will be NaNs
if isempty(kk),return,end 

% Start Main Calculation Loop 
for tt = 1:sz % loop through all input times

    dt_search = (t_input(tt,1) - sat_eph0(:,19))*604800 + (t_input(tt,2) - sat_eph0(:,17));
    dt_search(dt_search<-10)=[];
    [temp,dt_min_index] = min(abs(dt_search));
    if isempty(dt_min_index)
        return
    end
    if temp>2*3600
        % disp('Ephemeris expired!')
    end
    sat_eph = sat_eph0(dt_min_index,:);

    % Pull out variables from the epherimis matrix
    %======================================================================   
    Toe = sat_eph(17);
    gps_wk = sat_eph(19);
    dt  = (t_input(tt,1) - gps_wk)*604800 + (t_input(tt,2) - Toe); % seconds difference from epoch
    a   = sat_eph(5)^2;           % semimajor axis, sqrt(a) = gps_ephem_all(:,5) (meters)
    ecc = sat_eph(4);             % eccentricity
    n0  = sqrt(muE/a^3);          % nominal mean motion (rad/s)
    n   = n0 + sat_eph(3);        % corrected mean motion, delta_n = gps_ephem_all(:,3)
    M   = sat_eph(2) + n*dt;      % mean anomaly, M0 = gps_ephem_all(:,2)
    inc = sat_eph(7) ;            % inclination
    perigee  = sat_eph(8);     % argument of perigee

    % Compute true and eccentric anomaly...
    %======================================================================        
    % Compute Eccentric Anomaly, rad
    E    = mean2eccentric(M,ecc);
    cosE = cos(E);  
    sinE = sin(E);
    % Compute true anomaly, rad
    nu = atan2( sqrt(1 - ecc*ecc).*sinE,  cosE-ecc ); 
    % Compute the argument of latitude, rad 
    u = nu + perigee;  % true anomaly + argument of perigee

    % ####################################################### broadcast (task 1-1)
    Cuc = sat_eph(11); Cus = sat_eph(12); Crc = sat_eph(13); 
    Crs = sat_eph(14); Cic = sat_eph(15); Cis = sat_eph(16);
    du = Cus*sin(2*u) + Cuc*cos(2*u);
    dr = Crs*sin(2*u) + Crc*cos(2*u);
    di = Cis*sin(2*u) + Cic*cos(2*u);

    % Compute radius and inclination
    r = a * (1 - ecc*cosE) ;                        % corrected radius  
    
    % correction with 
    u = u+du;
    r = r+dr;
    inc = inc + di + dt*sat_eph(10);

    cosu = cos(u);      sinu = sin(u);  
    cos2u = cos(2*u);   sin2u = sin(2*u);

    % Compute satellite position in orbital plane
    xo = r * cosu;    % satellite x-position in orbital plane
    yo = r * sinu;    % satellite y-position in orbital plane

    % Corrected longitude of ascending node for node rate and Earth rotation
    node = sat_eph(6) + (sat_eph(9) - wE)*dt -  (wE * Toe); 

    % Calculate GPS Satellite Position in ECEF (m)
    cosi = cos(inc);    sini = sin(inc);
    coso = cos(node);   sino = sin(node);
    cosnu = cos(nu);   
    % Satellite position in ECEF (m)
    satPos(tt,1) = xo*coso - yo*cosi*sino;  %x-position  
    satPos(tt,2) = xo*sino + yo*cosi*coso;  %y-position 
    satPos(tt,3) = yo*sini;                 %z-position

    % Compute Rates of Change of true anomaly, arg. of lat., radius, inclination
    E_dot = n / (1-ecc*cosE);
    nu_dot = E_dot*sqrt(1-ecc^2) / (1-ecc*cosE);
    i_dot = sat_eph(10) + 2*nu_dot*(Cis*cos2u + Cic*sin2u);
    u_dot = nu_dot + 2*nu_dot*(Cus*cos2u-Cuc*sin2u);
    r_dot = a*ecc*sinE*n/(1-ecc*cosE) + 2*nu_dot*(Crs*cos2u-Crc*sin2u);
    node_dot = sat_eph(9) - wE;

    % Compute satellite velocity in orbital plane
    xo_dot = r_dot*cosu - yo*u_dot;
    yo_dot = r_dot*sinu + xo*u_dot;

    % Satellite position in ECEF (m/s)
    satVel(tt,1) = (xo_dot - yo*cosi*node_dot)*coso - (xo*node_dot + yo_dot*cosi - yo*sini*i_dot)*sino;
    satVel(tt,2) = (xo_dot - yo*cosi*node_dot)*sino + (xo*node_dot + yo_dot*cosi - yo*sini*i_dot)*coso;
    satVel(tt,3) = yo_dot*sini + yo*cosi*i_dot;

    % Satellite clocl bias (m)
    satClkCorr(tt,1) = c*((sat_eph(23)*dt + sat_eph(22))*dt + sat_eph(21)); % meters

    % Keep track of health of each satellite
    %======================================================================      
    health(tt,1) = sat_eph(25); % satellite health (0.00 is useable)

    % Calculate relativistic correction (p. 93 of IS-GPS-200G)
    relCorr(tt,1) = c * (4.442807633e-10 * ecc * sat_eph(5) * sinE); % meters
    % Sign corrected - PA

    tgd(tt,1) = c*sat_eph(24);

end % END of t_input loop =================================================
%==========================================================================    











    
    